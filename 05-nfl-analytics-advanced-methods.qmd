# Advanced Methods: Modeling and Big Data Bowl

```{r setup-ch5, include = FALSE}

source("book-functions.R")

library(tidyverse)
library(nflverse)
library(ggpmisc)
library(tidymodels)
library(lightgbm)
library(bonsai)
```

## Introduction to Statistics and Modeling with NFL Data

## Basic Statistical Modeling

### Linear Regressions

introduction to linear regressions here.

#### Simple Linear Regression

A simple linear regression is a fundamental statistical technique that is used to explore the relationship between two variables, specifically the dependent variable (also called the "response variable") and the independent variable (also called the "predictor"). By using a simple linear regression, we can model the relationship between the two variables as a linear equation that best fits the observed data points.

A simple linear regression aims to fit a straight line through all the observed data points in such a way that the total squared distance between the actual observations and the values predicted by the model are minimal. This line is often referred to as either the "line of best fit" or the "regression line" and it represents the interaction between the dependent and independent variables. Mathematically, the equation for a simple linear regression is as follows:

$$
Y = {\beta}_0 + {\beta}_1 * X + \epsilon
$$

1.  $Y$, in the above equation, is the dependent variable where the $X$ represents the independent variable.
2.  ${\beta}_o$ is the intercept of the regression model.
3.  ${\beta}_1$ is the slope of the model's "line of best fit."
4.  $\epsilon$ represents the error term.

To better illustrate this, let's use basic football terms using the above regression equation to compare a team's offensive points scored in a season based on how many offensive yards it accumulated. The intercept (${\beta}_o$) represents the value when a team's points scored and offensive yards are both zero. The slope (${\beta}_1$) represents the rate of change in $Y$ as the unit of $X$ changes. The error term ($\epsilon$) is represents the difference between the actual observed values of the regression's dependent variable and the value as predicted by the model.

Using our points scored/total yards example, a team's total yards gained is the **independent variable** and total points scored is the **dependent variable**, as a team's total yardage **is what drives the change in total points** (in other words, a team's total points *is dependent* on its total yardage).

fffff

```{r load-simple-regression-data, eval = TRUE, echo = TRUE, output = FALSE}

simple_regression_data <- vroom::vroom("https://raw.githubusercontent.com/bcongelio/nfl-analytics-with-r-book/origin/example_data/csv/simple_regression_data.csv")
```

#### Multiple Linear Regression

examples of multiple linear regression using nfl data.

### Logistic Regressions

introduction to logistic regressions here.

#### Binary Classification

examples of binary classification here using nfl data.

#### Multiclass Classification

examples of multiclass classification here using nfl data.

## Advanced Regression Techniques

### Regularization 

intro to regularization techniques here.

#### Ridge Regression

examples of ridge regression using nfl data.

#### Lasso Regression

examples of lasso regression using nfl data.

#### Elastic Ridge Regression

examples of elastic ridge regression using nfl data.

### Generalized Linear and Additive Models (GLM/GAM)

intro to both GLM and GAM here.

#### Poisson Regression (GLM)

example of poisson regression using nfl data.

#### Polynominal Regression(GAM)

example of polynominal regression using nfl data.

## Advanced Modeling Techniques

introduction to advanced modeling techniques in the nfl.

### Clustering

introduction to clustering.

#### K-means Clustering

examples of k-means clustering here.

#### Hierarchical Clustering

examples of hierarchical clustering here.

### Decision Trees/Random Forests

introduction to decision trees/random forests in nfl data.

#### Classification Trees

example of classification tree using nfl data.

#### Regression Trees

example of regression tree using nfl data.

## Creating Our Own Rushing Yards Over Expected Model

Back in January of 2021, Tej Seth posted an article to the [Michigan Football Analytics Society blog](https://mfootballanalytics.com/2021/01/14/creating-a-public-expected-rushing-yards-model/) that outlined his vision for creating a "public expected rushing yards model." The structure of his model, as explained by Tej, was inspired by the prior work of Michael Egle, an honorable mention in both the 2021 and 2023 NFL Big Data Bowl, who previously used the college football equivalent of open-source data ([`cfbfastR`](https://cfbfastr.sportsdataverse.org/)) to create an RYOE model for the collegiate game.[^05-nfl-analytics-advanced-methods-1] In Tej's case, his approach to created an NFL-centric RYOE model culminated with the creation of his [RYOE Shiny App](https://mfbanalytics.shinyapps.io/RYOE/) that allows anybody to explore his RYOE metric by season or team and even through three-way rusher comparisons.

[^05-nfl-analytics-advanced-methods-1]: Thanks to Tej Seth for briefly chatting with me over Twitter regarding the history of both Michael's RYOE model and his own.

Despite a slightly intimidating title, rushing yards over expected is a fantastic entrypoint into exploring model creation and analysis in NFL analytics - in fact, the growing number of "over expected" metrics in the NFL are all great ways to begin learning about and understanding advanced modeling. Robby Greerre, the owner of [nfeloapp.com](https://www.nfeloapp.com/) - a website that provides "data-driven analytics, picks, and predictions for the NFL" - explains that over expected metrics are a increasingly popular avenue in which analysts can "paint a more accurate picture of performance by adjusting familiar statistics like 'completion percentage' or 'yards per rush' for conflating factors like degree of difficulty or game text" [@nfelo].

Some of these metrics, like completion percentage over expected (CPOE), are widely accepted. Specifically, CPOE calculates how likely any quarterback's pass is going to be complete or incomplete compared to other passing attempts. It is considered "widely accepted" because the metric itself is considered "stable" in that the r-squared value retains a strong correlation for individual quarterbacks across several seasons. In fact, as Greerre points out, the r-squared value for CPOE for just one season is 0.226 which is extremely strong based on NFL analytics standards.

On the other hand, RYOE - based on Greerre's analysis - maintains an r-squared value below 0.15 until a running back's fourth season, wherein the average improves to 0.263 (an otherwise stable value). But that does not mean that RYOE is not a metric worth further exploration. The effectiveness of any one metric to account for factors such as degree of difficulty or game text largely relies on our ability to provide adequate feature engineering - specifically, how much relevant data the machine learning model can ingest to begin making predictions.

Because of that, significant machine learning models have been built with information provided by the NFL's Big Data Bowl as it is the one chance that the public receives to feature engineer with the NFL's tracking data (wherein a player's position, speed, direction, etc. is tracked and recorded every 1/10th of a second). Unfortunately, only small windows of data exist from the Big Data Bowl releases and, as a result, we are often required to find creative ways to provide further context to each play/player for the machine learning model.

To showcase this idea, we are going to begin exploring ways to add additional feature engineering to Tej Seth's already fantastic Rushing Yard Over Expected model. While not the most stable metric, as mentioned, the idea of RYOE is generally easy to understand for even the most analyst. Broadly, given what we know about every other rushing play during a specific span of seasons, what is the most likely amount of yards a running back is going to gain on a specific rushing play as predicted by the model on other similar situations?

**That difference is rushing yards over expected**.

Using Tej's Shiny app, we can explore all seasons between 2015 and 2022 for those running backs that had a minimum of 755 rushing attempts.

```{r tej-seth-shiny-results, echo = FALSE, fig.cap = "Credit: Tej Seth"}
knitr::include_graphics(rep("images/ryoe_2015_2022.jpg"))
```

According to Tej's model, since 2015, Nick Chubb of the Cleveland Browns earned - on average - 0.66 over expected. Aaron Jones is closely behind with 0.61 over expected and then a significant drop occurs for the third and fourth players.

To understand how Tej engineered his model and to begin exploring other possible features to feed into the model, we can dive into his [publicly available code](https://github.com/tejseth/RYOE/blob/main/ryoe-2.R).

### Tej Seth's RYOE Model: Under The Hood

::: callout-important
It is important to immediately point out that Tej built his RYOE model using the `xgboost` package whereas we will begin constructing ours using `tidymodels`.

While the underlying eXtreme Gradient Boosting process is largely the same with both approaches, the necessary framework we will construct with `tidymodels` differs *greatly* from the coding used with the `xgboost` package.

The `xgboost` package is a standalone package in R that provide an implementation of the eXtreme Gradient Boosting algorithm. To that end, it offers a highly efficient and flexible way to train gradient boosting models for various machine learning tasks, such as classification, regression, and ranking. The package provides its own set of functions for training, cross-validation, prediction, and feature importance evaluation.

The `tidymodels` package, on the other hand, is a *collection* of R packages that provide a unified framework for modeling and machine learning tasks. It includes several package for data preprocessing, modeling, validation, and evaluation. Because of this, the core goal of the `tidymodels` teams is to offer a consistent syntax and workflow for a wide range of machine learning models. It is a fair comparison to say that `tidymodels` is the `tidyverse` of the machine learning world.
:::

Just like the model we will be building in this chapter, Tej constructed his model via eXtreme Gradient Boosting.

Which may lead to a very obvious question if you are new to machine learning: **what exactly *is* eXtreme Gradient Boosting?**

### eXtreme Gradient Boosting Explained

eXtreme Gradient Boosting (XGBoost) is a powerful machine learning technique that is particularly good at solving supervised machine learning problems, such as classification (categorizing data into classes, for example) and regression (predicting numerical values).

XGBoost can be thought of as an "expert team" that combines the knowledge and skills of multiple "individual experts" to make better decisions or predictions. Each of these "experts" in this context is what we call a decision tree, which is a flowchart structure used for making decisions based on a series of question about the data.

Once provided data, XGBoost seeks to iteratively build a collection of "bad" decision trees and then build an ensemble of these poor ones into a more accurate and robust model. The term "gradient" comes from the fact that the algorithm uses the gradient (or the slope) of the loss function (a measure of how well the model fits the data) to guide the learning process.

## Building a RYOE Model with `tidymodels`

Place holding for the tidymodels code below.

```{r ryoe-model-in-tidy, eval = FALSE, echo = TRUE, output = FALSE}

library(tidyverse)
library(nflverse)
library(tidymodels)
library(tune)
library(bon)

options(scipen = 999)
options(digits = 3)

### reading in NFL play-by-play data from 2016 to 2022
pbp <- nflreadr::load_pbp(2016:2022)

### filtering to just rushing attempts that are not missing any yards_gained
rush_attempts <- pbp %>%
  filter(season_type == "REG") %>%
  filter(rush_attempt == 1, qb_scramble == 0,
         qb_dropback == 0, !is.na(yards_gained)) 

### quickly calculating each defteam's avg. rushing yards allowed per season
def_ypc <- rush_attempts %>%
  filter(!is.na(defteam)) %>%
  group_by(defteam, season) %>%
  summarize(def_ypc = mean(yards_gained))

### joining the defteam avg yards gained into the rushing data
rush_attempts <- rush_attempts %>%
  left_join(def_ypc, by = c("defteam", "season"))

### gathering offensive formation, offensive personnel, defensive personnel, and defenders in box
participation <- nflreadr::load_participation(seasons = 2016:2022) %>%
  select(nflverse_game_id, play_id, possession_team, offense_formation,
         offense_personnel, defense_personnel, defenders_in_box)

### merging participation data into our rushing attempts data
### note: the team match is likely not necessary but I was being careful
rush_attempts <- rush_attempts %>%
  left_join(participation, by = c("game_id" = "nflverse_game_id",
                                  "play_id" = "play_id",
                                  "posteam" = "possession_team"))

### creating a secondary dataframe for joining back in player names
rushing_data_join <- rush_attempts %>%
  group_by(game_id, rusher, fixed_drive) %>%
  mutate(drive_rush_count = cumsum(rush_attempt)) %>%
  ungroup() %>%
  group_by(game_id, rusher) %>%
  mutate(game_rush_count = cumsum(rush_attempt)) %>%
  mutate(rush_prob = (1 - xpass) * 100,
         strat_score = rush_prob / defenders_in_box,
         wp = wp * 100) %>%
  ungroup() %>%
  mutate(red_zone = if_else(yardline_100 <= 20, 1, 0),
         fg_range = if_else(yardline_100 <= 35, 1, 0),
         two_min_drill = if_else(half_seconds_remaining <= 120, 1, 0)) %>%
  select(label = yards_gained, season, week, yardline_100, quarter_seconds_remaining,
         half_seconds_remaining, qtr, down, ydstogo, shotgun, no_huddle,
         ep, wp, drive_rush_count, game_rush_count, red_zone, fg_range, two_min_drill,
         offense_formation, offense_personnel, defense_personnel, defenders_in_box,
         rusher, rush_prob, def_ypc, strat_score, rusher_player_id, posteam, defteam) %>%
  na.omit()

### bringing in pre-aggregated next gen stats
next_gen_stats <- nflreadr::load_nextgen_stats(seasons = 2016:2022, stat_type = "rushing") %>%
  filter(week > 0 & season_type == "REG") %>%
  select(season, week, player_gsis_id,
         against_eight = percent_attempts_gte_eight_defenders, avg_time_to_los)

### merging in next gen stats
rushing_data_join <- rushing_data_join %>%
  left_join(next_gen_stats, by = c("season", "week", "rusher_player_id" = "player_gsis_id")) %>%
  na.omit()

### placing offense personnel positions in individual columns
### new column: extra_ol
rushing_data_join <- rushing_data_join %>%
  mutate(
    ol = str_extract(offense_personnel, "(?<=\\s|^)\\d+(?=\\sOL)") %>% as.numeric(),
    rb = str_extract(offense_personnel, "(?<=\\s|^)\\d+(?=\\sRB)") %>% as.numeric(),
    te = str_extract(offense_personnel, "(?<=\\s|^)\\d+(?=\\sTE)") %>% as.numeric(),
    wr = str_extract(offense_personnel, "(?<=\\s|^)\\d+(?=\\sWR)") %>% as.numeric()) %>%
  replace_na(list(ol = 5)) %>%
  mutate(extra_ol = if_else(ol > 5, 1, 0)) %>%
  mutate(across(ol:wr, as.factor)) %>%
  select(-ol, -offense_personnel)

### doing some as above but for defense personnel
rushing_data_join <- rushing_data_join %>%
  mutate(dl = str_extract(defense_personnel, "(?<=\\s|^)\\d+(?=\\sDL)") %>% as.numeric(),
         lb = str_extract(defense_personnel, "(?<=\\s|^)\\d+(?=\\sLB)") %>% as.numeric(),
         db = str_extract(defense_personnel, "(?<=\\s|^)\\d+(?=\\sLB)") %>% as.numeric()) %>%
  mutate(across(dl:db, as.factor)) %>%
  select(-defense_personnel)

rushing_data_join <- rushing_data_join %>%
  filter(qtr < 5) %>% ### let's remove rushes that took place in OT
  mutate(qtr = as.factor(qtr),
         down = as.factor(down),
         shotgun = as.factor(shotgun),
         no_huddle = as.factor(no_huddle),
         red_zone = as.factor(red_zone),
         fg_range = as.factor(fg_range),
         two_min_drill = as.factor(two_min_drill),
         extra_ol = as.factor(extra_ol))

### going to build model from rushes so will remove identifying information
rushes <- rushing_data_join %>%
  select(-season, -week, -rusher, -rusher_player_id, -posteam, -defteam) %>%
  mutate(across(where(is.character), as.factor))

str(rushes)

#################################
## tidymodels work now
################################
set.seed(1984)

str(rushes)

rushing_split <- initial_split(rushes)
rushing_train <- training(rushing_split)
rushing_test <- testing(rushing_split)
rushing_folds <- vfold_cv(rushing_train)

### creating our xgboost recipe
rushing_recipe <-
  recipe(formula = label ~ ., data = rushing_train) %>%
  step_dummy(all_nominal_predictors(), one_hot = TRUE)

### creating the model boosting tree specifications
rushing_specs <- boost_tree(
  trees = tune(),
  tree_depth = tune(), 
  min_n = tune(),
  mtry = tune(),
  loss_reduction = tune(),
  sample_size = tune(),
  learn_rate = tune(),
  stop_iter = tune()) %>%
  set_engine("lightgbm", num_leaves = tune()) %>%
  set_mode("regression")

### creating the tuning grid
rushing_grid <- grid_latin_hypercube(
  trees(),
  tree_depth(),
  finalize(mtry(), rushes),
  min_n(),
  num_leaves(),
  loss_reduction(),
  sample_size = sample_prop(),
  learn_rate(),
  stop_iter(),
  size = 5)

### adding everything into the workflow
rushing_workflow <-
  workflow() %>%
  add_recipe(rushing_recipe) %>%
  add_model(rushing_specs)

registerDoSEQ() ### to leave parallel processing
registerDoParallel(cores = 11)
doParallel::stopImplicitCluster()

### tuning the grid with tictoc() running to see how long it takes
tic()
rushing_tune <-
  tune_grid(rushing_workflow, resamples = rushing_folds, grid = rushing_grid, control = control_grid(save_pred = TRUE,
                                                                                                     verbose = TRUE))
toc() ## 344.16 seconds/5 minutes (100 trees, 30 grid)
      ## 5783.15 seconds/ 96 minutes (1000 trees, 60 grid)
      ## 15643.44 seconds / 4.5 hours (tune() trees, 100 grid)

### extracting the best performing hyperparameters from the tuning results
best_params <- rushing_tune %>%
  select_best(metric = "rmse")

### creating a final workflow with this updated model specification
rushing_final_workflow <- rushing_workflow %>%
  finalize_workflow(best_params)

### fitting the workflow on the testing data
final_model <- rushing_final_workflow %>%
  fit(data = rushing_test)

### using final mod to add the predictins to our prior rushing_data_join information
rushing_predictions <- predict(final_model, rushing_data_join)

### creating our projections
ryoe_projs <- cbind(rushing_data_join, rushing_predictions) %>%
  rename(actual_yards = label,
         exp_yards = .pred)

### doing some math to find the league-wide average of mean_ryoe per season
mean_ryoe <- ryoe_projs %>%
  dplyr::group_by(season) %>%
  summarize(nfl_mean_ryoe = mean(actual_yards) - mean(exp_yards))

### merging in the mean_ryoe into the data per season
ryoe_projs <- ryoe_projs %>%
  left_join(mean_ryoe, by = c("season" = "season"))

### taking a player's actual yards minus his expected yards and then weighing it against NFL average per season
ryoe_projs <- ryoe_projs %>%
  mutate(ryoe = actual_yards - exp_yards + nfl_mean_ryoe)

### outputting the results
ryoe_projs %>%
  group_by(rusher) %>%
  summarize(
    rushes = n(),
    yards = sum(actual_yards),
    exp_yards = sum(exp_yards),
    ypc = yards / rushes,
    exp_ypc = exp_yards / rushes,
    avg_ryoe = mean(ryoe)) %>%
  filter(rushes > 1000) %>%
  arrange(-avg_ryoe)
```

fffff

```{r ryoe-r2-plot, eval = FALSE, echo = TRUE, output = FALSE}

ggplot(data = for_plot, aes(x = yards, y = exp_yards)) +
  stat_poly_line(formula = y ~ x + 0, 
                 se = FALSE, color = "black", 
                 linewidth = .8, linetype = "dashed") +
  stat_poly_eq(formula = y ~ x + 0,
               aes(label = after_stat(rr.label), 
                   family = "Roboto Condensed", 
                   size = 9, fontface = "bold"),
               label.y = 1, label.x = 0.4) +
  geom_point(shape = 21, fill = for_plot$team_color, 
             color = for_plot$team_color2, size = for_plot$rushes / 200) +
  scale_x_continuous(breaks = scales::pretty_breaks(),
                     label = scales::comma_format()) +
  scale_y_continuous(breaks = scales::pretty_breaks(),
                     label = scales::comma_format()) +
  nfl_analytics_theme() +
  labs(x = "Actual Rushing Yards",
       y = "Expected Rushing Yards",
       title = "Actual Rushing Yards vs. Expected Rushing Yards",
       subtitle = "2016 - 2022   |   Model: LightGBM",
       caption = "An Introduction to NFL Analytics with R\nBrad J. Congelio") +
  geom_text_repel(data = filter(for_plot, yards >= 4500),
                  aes(label = rusher), box.padding = .8, 
                  point.padding = 1, family = "Roboto Condensed")

```

## Navigating the NFL's Big Data Bowl

lots of place holding for Big Data Bowl material below

Thomas Bliss, a Data Scientist with the NFL, [provided an incredibly helpful list of potential topics](https://www.kaggle.com/competitions/nfl-big-data-bowl-2023/discussion/365497) that can be explored using 2023 Big Data Bowl information:

1.  analyze blocker positioning after the QB leaves the pocket and/or is pressured
2.  analyze blocker ability to hold a defender in place without moving towards the QB
3.  link the rate of false starts to an offensive line's time off the snap
4.  link between QB release time, receiver separation, and offensive line performance

```{r bdb-reading-writing-data, eval = FALSE, echo = TRUE}

### reading all weeks and writing to a parquet file
all_bdb_weeks <- function(dir = file.path('core-data')) {
  paths <- fs::dir_ls(dir, regexp = 'week\\d+')
  all_weeks <-
    paths %>%
    purrr::map_df(vroom::vroom) %>%
    janitor::clean_names() %>%
    arrow::write_parquet(file.path('core-data', 'data.parquet'))
}

all_bdb_weeks()

### reading in all play information provided and writing to a parquet file
read_bdb_plays <- memoise::memoise({function() {
  plays <- file.path('core-data', 'plays.csv') %>%
    readr::read_csv() %>%
    janitor::clean_names() %>%
    arrow::write_parquet(file.path('core-data', 'plays.parquet'))
}})

read_bdb_plays()

### reading in individual game information and writing to a parquet file
read_game_info <- memoise::memoise({function() {
  file.path('core-data', 'games.csv') %>%
    readr::read_csv() %>%
    janitor::clean_names() %>%
    dplyr::mutate(dplyr::across(game_date = lubridate::mdy)) %>%
    arrow::write_parquet(file.path('core-data', 'games.parquet'))
}})

### creating an individual .cvs file for each game in bdb
all.weeks <- read_parquet("./core-data/large-lfs-files/all-weeks-parquet")

all.weeks %>%
  group_by(game_id) %>%
  group_walk(~ write_csv(.x, paste0('tracking_gameId_', .y$game_id, ".csv")))

### writing in team colors, logos
team.colors <- nflfastR::teams_colors_logos %>%
  select(team_abbr, team_color, team_color2, team_logo_espn)
```

fffff

```{r roating-dots-function, eval = FALSE, echo = TRUE}

rotate_the_dots <- function(df) {
  
  if(!"play_direction" %in% names(df)) {
    message("Cannot find play directions. Inferring from offense and defense locations at snap.")
    
    df <- df %>%
      filter(event == "ball_snap", team != "football") %>%
      group_by(game_id, play_id, defensive_team) %>%
      summarize(mean_x = mean(x, na.rm = T)) %>%
      pivot_wider(names_from = defensive_team, values_from = mean_x, names_prefix = "x_") %>%
      ungroup() %>%
      mutate(
        play_direction = 
          ifelse(
            x_1 > x_0,
            "right",
            "left") %>%
          select(game_id, play_id, play_direction) %>%
          inner_join(df, by = c("game_id", "play_id")))
        
  }
  
  df <- df %>%
    mutate(
      to_left = ifelse(play_direction == "left", 1, 0),
      x = ifelse(to_left == 1, 120 - x, x),
      y = ifelse(to_left == 1, 160 / 3 - y, y),
      los_x = 100 - absolute_yardline_number,
      dist_from_los = x - los_x)
  
  if ("o" %in% names(df)) {
    df <- df %>%
      mutate(
        o = ifelse(to_left == 1, o + 180, o),
        o = ifelse(o > 360, 0 - 360, o),
        o_rad = pi * (o / 180),
        o_x = ifelse(is.na(o), NA_real_, sin(o_rad)),
        o_y = ifelse(is.na(o), NA_real_, cos(o_rad)))
  }
  
  if ("dir" %in% names(df)) {
    df <- df %>%
      mutate(
        dir = ifelse(to_left == 1, dir + 180, dir),
        dir = ifelse(dir > 360, dir - 360, dir),
        dir_rad = pi * (dir / 180),
        dir_x = ifelse(is.na(dir), NA_real_, sin(dir_rad)),
        dir_y = ifelse(is.na(dir), NA_real_, cos(dir_rad)),
        s_x = dir_x * s,
        s_y = dir_y * s,
        a_x = dir_x * a,
        a_y = dir_y * a)
  }
  
  return(df)
}

```

ffff

```{r finding-orientation-difference, eval = FALSE, echo = TRUE}

find_o_diff <- function(df, prefix = "qb") {
  
  name_x <- sym(paste0(prefix, "_x"))
  name_y <- sym(paste0(prefix, "_y"))
  
  new_column <- paste0("o_to_", prefix)
  
  df <- df %>%
    mutate(
      dis_x = {{name_x}} - x,
      dis_y = {{name_y}} - y,
      
      tmp = atan2(dis_y, dis_x) * (180 / pi),
      tmp = (360 - tmp) + 90,
      tmp = case_when(tmp < 0 ~ tmp + 360,
                      tmp > 360 ~ tmp - 360,
                      TRUE ~ tmp),
      
      diff = abs(o - tmp),
      
      diff = abs(o - tmp),
      
      !!new_column := pmin(360 - diff, diff)) %>%
        select(-diff, -tmp)
      
    return(df)
}

```

```{r building-convex-hulls, eval = FALSE, echo = TRUE}

########
## READING IN PITTSBURGH VS. BUFFALO - WEEK 1
########

pitt.buff <- arrow::read_parquet("core-data/large-lfs-files/all-weeks-parquet") %>%
  filter(game_id == "2021091201")

########
## READING IN PLAYS FROM PITTSBURGH VS. BUFFALO - WEEK 1
########

pitt.buff.plays <- readr::read_csv("core-data/plays.csv") %>%
  janitor::clean_names() %>%
  filter(game_id == "2021091201")

########
## READING IN GAME INFO FROM PITTSBURGH VS. BUFFALO - WEEK 1
########

pitt.buff.info <- readr::read_csv("core-data/games.csv") %>%
  janitor::clean_names() %>%
  filter(game_id == "2021091201")

########
## COMBING CORE GAME FILE WITH PLAYS, AND THEN BY INFO (TO AVOID MULTIPLE GAME_IDs IN DF)
########

complete.data <- inner_join(pitt.buff, pitt.buff.plays, by = c("game_id" = "game_id", "play_id" = "play_id"))

complete.data <- complete.data %>%
  inner_join(pitt.buff.info, by = c("game_id" = "game_id"))

### ROTATING THE DOTS
complete.data <- rotate_the_dots(complete.data)

########
## MUTATING TO CHARACTER VARIABLE DEFINING WHETHER TEAM IN FRAMES IS ON OFFENSE OR DEFENSE
########

complete.data <- complete.data %>%
  mutate(off_or_def = case_when(
    team == possession_team ~ "offense",
    team != possession_team ~ "defense",
    TRUE ~ "football"))

            ########
            ## CORE CLEANING AND PREP IS COMPLETE
            ########

########
## ADDING IN INFORMATION FROM PLAYERS.CSV TO BUILD CHULLs FOR JUST O-LINE
########

player.info <- readr::read_csv("core-data/players.csv") %>%
  janitor::clean_names() %>%
  select(nfl_id, official_position, display_name)

complete.data <- complete.data %>%
  inner_join(player.info, by = c("nfl_id" = "nfl_id"))

########
## LET'S PICK OUT A FUN PLAY TO WORK WITH
########

one.play <- complete.data %>%  ### BEN PASS TO EBRON FOR 19 YARDS
  filter(play_id == 2209)

########
## NOW LET'S BUILD A CONVEX HULL FOR JUST THE OFFENSIVE LINE
########

ol_chull_order <- one.play %>%
  filter(off_or_def == "offense") %>%
  filter(official_position %in% c("T", "C", "G")) %>%  #### IMPORTANT TO KNOW PERSONNEL PACKAGE HERE: 0 RB, 0 TE, 5 WR
  select(frame_id, x, y) %>%
  chull

ol_chull_order <- c(ol_chull_order, ol_chull_order[1])

ol_chull_coords <- one.play %>%
  filter(off_or_def == "offense") %>%
  select(frame_id, x, y) %>%
  slice(ol_chull_order)

ol_chull_poly <- sp::Polygon(ol_chull_coords, hole = F)
ol_chull_area <- ol_chull_poly@area

########
## NOW LET'S PLOT IT
########

one.play %>%
  the_dots(
    animated = TRUE,
    orientation = FALSE,
    convex = TRUE,
    segment_length = 6,
    segment_size = 3,
    dot_size = 4,
    animated_h = 4,
    animated_w = 8,
    animated_res = 150
  )

```
